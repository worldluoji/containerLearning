1. Kubernetes项目的架构，跟它的原型项目 Borg 非常类似，都由 Master 和 Node 两种节点组成，
而这两种角色分别对应着控制节点和计算节点。

虽然在 Master 节点的实现细节上 Borg 项目与 Kubernetes 项目不完全相同，
但它们的出发点却高度一致，即：如何编排、管理、调度用户提交的作业？

Borg 项目完全可以把 Docker 镜像看作一种新的应用打包方式。
这样，Borg 团队过去在大规模作业管理与编排上的经验就可以直接“套”在 Kubernetes 项目上了。

这些经验最主要的表现就是：从一开始，Kubernetes 项目就没有像同时期的各种“容器云”项目那样，
把 Docker 作为整个架构的核心，而仅仅把它作为最底层的一个容器运行时实现。

2. 控制节点
即 Master 节点，由三个紧密协作的独立组件组合而成，
它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，
以及负责容器编排的 kube-controller-manager。
整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。


3. 计算节点
计算节点上最核心的部分，则是一个叫作 kubelet 的组件。
kubelet 主要负责同容器运行时（比如 Docker 项目）打交道。
而这个交互所依赖的，是一个称作 CRI（Container Runtime Interface）的远程调用接口，
这个接口定义了容器运行时的各项核心操作，比如：启动一个容器需要的所有参数。
所以，Kubernetes 项目并不关心你部署的是什么容器运行时、使用的什么技术实现，
只要你的这个容器运行时能够运行标准的容器镜像，它就可以通过实现 CRI 接入到 Kubernetes 项目当中。

具体的容器运行时，比如 Docker 项目，则一般通过 OCI 这个容器运行时规范同底层的 Linux 操作系统进行交互，
即：把 CRI 请求翻译成对 Linux 操作系统的调用（操作 Linux Namespace 和 Cgroups 等）。

此外，kubelet 还通过 gRPC 协议同一个叫作 Device Plugin 的插件进行交互。
这个插件，是 Kubernetes 项目用来管理 GPU 等宿主机物理设备的主要组件，
也是基于 Kubernetes 项目进行机器学习训练、高性能作业支持等工作必须关注的功能。


而 kubelet 的另一个重要功能，则是调用网络插件和存储插件为容器配置网络和持久化存储。
这两个插件与 kubelet 进行交互的接口，分别是 CNI（Container Networking Interface）和 
CSI（Container Storage Interface）。

实际上，kubelet 这个奇怪的名字，来自于 Borg 项目里的同源组件 Borglet。
不过，如果你浏览过 Borg 论文的话，就会发现，这个命名方式可能是 kubelet 组件与 Borglet 组件的唯一相似之处。
因为 Borg 项目，并不支持我们这里所讲的容器技术，而只是简单地使用了 Linux Cgroups 对进程进行限制。
可以说，kubelet 完全就是为了实现 Kubernetes 项目对容器的管理能力而重新实现的一个组件，
与 Borg 之间并没有直接的传承关系。


4. Kubernetes 项目要着重解决的问题
Kubernetes 项目要着重解决的问题，则来自于 Borg 的研究人员在论文中提到的一个非常重要的观点：
运行在大规模集群中的各种任务之间，实际上存在着各种各样的关系。
这些关系（比如负载均衡、应用和DB的关系）的处理，才是作业编排和管理系统最困难的地方。

传统虚拟机环境对这种关系的处理方法都是比较“粗粒度”的。
你会经常发现很多功能并不相关的应用被一股脑儿地部署在同一台虚拟机中，只是因为它们之间偶尔会互相发起几个 HTTP 请求。
一个应用被部署在虚拟机里之后，你还得手动维护很多跟它协作的守护进程（Daemon），用来处理它的日志搜集、灾难恢复、数据备份等辅助工作。

但容器技术出现以后，你就不难发现，在“功能单位”的划分上，容器有着独一无二的“细粒度”优势：
毕竟容器的本质，只是一个进程而已。

也就是说，只要你愿意，那些原先拥挤在同一个虚拟机里的各个应用、组件、守护进程，都可以被分别做成镜像，
然后运行在一个个专属的容器中。
它们之间互不干涉，拥有各自的资源配额，可以被调度在整个集群里的任何一台机器上。
而这，正是一个 PaaS 系统最理想的工作状态，也是所谓“微服务”思想得以落地的先决条件。

Kubernetes 项目最主要的设计思想是，从更宏观的角度，以统一的方式来定义任务之间的各种关系，
并且为将来支持更多种类的关系留有余地。
比如，在 Kubernetes 项目中，这些容器则会被划分为一个“Pod”，Pod 里的容器共享同一个 Network Namespace、同一组数据卷，从而达到高效率交换信息的目的。