1.什么是容器？
  容器是一种特殊的进程，一般容器中只运行一个应用（例如：eureka-server镜像）。
  
2.容器是怎么来的？
  通过镜像创建容器，通过docker run命令创建。
  
3.容器有什么作用？
  容器起到了隔离的作用，独享空间、网络等等。

4.docker run --help
	-d, --detach=false         指定容器运行于前台还是后台，默认为false
	-i, --interactive=false    打开STDIN，用于控制台交互
	-t, --tty=false            分配tty设备，该可以支持终端登录，默认为false
	-u, --user=""              指定容器的用户
	-a, --attach=[]            登录容器（必须是以docker run -d启动的容器）
	-w, --workdir=""           指定容器的工作目录
	-c, --cpu-shares=0         设置容器CPU权重，在CPU共享场景使用
	-e, --env=[]               指定环境变量，容器中可以使用该环境变量
	-m, --memory=""            指定容器的内存上限
	-P, --publish-all=false    指定容器暴露的端口
	-p, --publish=[]           指定容器暴露的端口，支持的格式有 hostPort:containerPort、ip:hostPort:containerPort、 ip::containerPort
	-h, --hostname=""          指定容器的主机名
	-v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录
	--volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录
	--cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities
	--cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities
	--cidfile=""               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法
	--cpuset=""                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU
	--device=[]                添加主机设备给容器，相当于设备直通
	--dns=[]                   指定容器的dns服务器
	--dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件
	--entrypoint=""            覆盖image的入口点
	--env-file=[]              指定环境变量文件，文件格式为每行一个环境变量
	--expose=[]                指定容器暴露的端口，即修改镜像的暴露端口
	--link=[]                  指定容器间的关联，使用其他容器的IP、env等信息
	--lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用
	--name=""                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字
	--net="bridge"             容器网络设置:
	                              bridge 使用docker daemon指定的网桥
	                              host    //容器使用主机的网络
	                              container:NAME_or_ID  >//使用其他容器的网路，共享IP和PORT等网络资源
	                              none 容器使用自己的网络（类似--net=bridge），但是不进行配置
	--privileged=false         指定容器是否为特权容器，特权容器拥有所有的capabilities
	--restart="no"             指定容器停止后的重启策略:
	                              no：容器退出时不重启
	                              on-failure：容器故障退出（返回值非零）时重启
	                              always：容器退出时总是重启
	--rm=false                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)
	--sig-proxy=true           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理
	
5.启动容器
	docker run -d -p 5000:5000 \
	--restart=always \
	--privileged=true \
	--name=registry-agan \
	-v /date/volume/registry:/var/lib/registry \
	registry

6.查看容器
	查看正在运行的容器：docker ps 
	查看所有的容器包含已经停止的： docker ps -a
	
7.停止容器
	停止容器：docker stop  容器ID
	强制停止容器：docker kill 容器ID
	
8.启动容器
  启动容器：docker start 容器ID
  重启容器：docker restart 容器ID
  
9.删除容器
  删除已经停止的容器： docker rm 容器ID
  删除正在运行容器，强制删除： docker rm -f 容器ID
  

 查看日志：
docker logs -f -t --tail 20 容器ID
  
补充：
查看已有容器：# docker inspect  [ id ]  (对容器详细检查，返回配置信息、包括：名称、命令、
网络配置等)
删除已停止容器：# docker rm 容器名
启动容器：# docker start 容器名  (-i：交互方式启动）
查看日志：docker log 容器id
查看状态：docker stats 容器id
查看运行中容器进程：docker top 容器id
查看容器：# docker ps (-a：所有容器、-l：最新创建容器）
  
  
守护式容器：
能够长期运行
没有交互式会话
适合运行应用程序和服务
1、以交互式运行容器：
# docker run –i –t IMAGE /bin/bash
? -i(--interactive=ture)：docker守护进程始终打开标准输入
? -t(--tty=true)：为创建的容器分配一个tty终端（伪输入终端）
# Ctrl+p + ctrl+q
# docker attach 容器id
2、以守护式运行容器：
# docker run –d IMAGE /bin/bash –c “top”  （-d：容器启动后会进入后台）
  
  
  